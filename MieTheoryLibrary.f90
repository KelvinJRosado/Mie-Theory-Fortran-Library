! =========================================================
! =========================================================
!
!Fortran 95 Mie Theory library
!by Kelvin Rosado, Reed Hodges, and Maxim Durach
!
!contact: kr04537@georgiasouthern.edu OR
!	 hodges.reed@gmail.com 	     OR
!	 mdurach@georgiasouthern.edu
!
!
!First created: July 2016
!Last updated: August 19, 2017

! =========================================================
! =========================================================

function hankel(N,X)

! =========================================================
! Name:    function hankel
!
! Purpose: calculating Spherical Hankel functions of the 
!          first kind, h_N(x)
!
! Input:   N    -> the order of the function
!          X    -> the argument of the function
! 
! Output:  hankel -> the spherical Hankel function of the
!                    first kind of order N and argument X
!
! Calls:   function bessel, function bessel2
! =========================================================

    implicit none
    doubleprecision :: bessel, bessel2, X, b1, b2
    integer :: N
    complex*16 :: hankel

    b1 = bessel(N,X)
    b2 = bessel2(N,X)

    hankel = complex(b1,b2)

end function

function bessel(L,x)

! =========================================================
! Name:    function bessel
!
! Purpose: calculating Spherical Bessel functions of the 
!          first kind, j_L(x)
!
! Input:   L    -> the order of the function
!          X    -> the argument of the function
! 
! Output:  bessel -> the spherical Bessel function of the
!                    first kind of order L and argument X
!
! Calls:   N/A
! =========================================================

    doubleprecision :: bessel, x
    integer :: L

if (L==0) then
    bessel=Sin(x)/x

else if (L==1) then
    bessel=-(Cos(x)/x) + Sin(x)/x**2

else if (L==2) then
    bessel=(-3*Cos(x))/x**2 + ((3 - x**2)*Sin(x))/x**3

else if (L==3) then
    bessel=((-15 + x**2)*Cos(x))/x**3 - (3*(-5 + 2.0*x**2)*Sin(x))/x**4

else if (L==4) then
    bessel=(5*(-21 + 2.0*x**2)*Cos(x))/x**4 + ((105 - 45.0*x**2 + x**4)*Sin(x))/x**5

else if (L==5) then
    bessel=((-945 + 105.0*x**2 - x**4)*Cos(x))/x**5 + (15*(63 - 28.0*x**2 + x**4)*Sin(x))/x**6

else if (L==6) then
    bessel=(-21*(495 - 60.0*x**2 + x**4)*Cos(x))/x**6 + ((10395 - 4725.0*x**2 + 210.0*x**4 - x**&
    6)*Sin(x))/x**7

else if (L==7) then
    bessel=((-135135 + 17325.0*x**2 - 378.0*x**4 + x**6)*Cos(x))/x**7 - (7*(-19305 + 8910.0*x**2&
     - 450.0*x**4 + 4.0*x**6)*Sin(x))/x**8

else if (L==8) then
    bessel=(9*(-225225 + 30030.0*x**2 - 770.0*x**4 + 4.0*x**6)*Cos(x))/x**8 + ((2027025 - 945945.0&
    *x**2 + 51975.0*x**4 - 630.0*x**6 + x**8)*Sin(x))/x**9

else if (L==9) then
    bessel=((-34459425.0 + 4729725.0*x**2 - 135135.0*x**4 + 990.0*x**6 - x**8)*Cos(x))/x**9 + (45*&
    (765765.0 - 360360.0*x**2 + 21021.0*x**4 - 308.0*x**6 + x**8)*Sin(x))/x**10

else if (L==10) then
    bessel=(-55*(11904165.0 - 1670760.0*x**2 + 51597.0*x**4 - 468.0*x**6 + x**8)*Cos(x))/x**10 + &
    ((654729075.0 - 310134825.0*x**2 + 18918900.0*x**4 - 315315.0*x**6 + 1485.0*x**8 - x**10)*Sin(x))/x**11

else if (L==11) then
    bessel=((-13749310575.0 + 1964187225.0*x**2 - 64324260.0*x**4 + 675675.0*x**6 - 2145.0*x**8 + x**&
    10)*Cos(x))/x**11 - (33*(-416645775.0 + 198402750.0*x**2 - 12530700.0*x**4 + 229320.0*x**6 - 1365.0&
    *x**8 + 2.0*x**10)*Sin(x))/x**12

else if (L==12) then
    bessel=(39*(-8108567775.0 + 1175154750.0*x**2 - 40291020.0*x**4 + 471240.0*x**6 - 1925.0*x**8 + 2*&
    x**10)*Cos(x))/x**12 + ((316234143225.0 - 151242416325.0*x**2 + 9820936125.0*x**4 - 192972780*&
    x**6 + 1351350.0*x**8 - 3003.0*x**10 + x**12)*Sin(x))/x**13

else if (L==13) then
    bessel=((-7905853580625.0 + 1159525191825.0*x**2 - 41247931725.0*x**4 + 523783260.0*x**6 - 2552550*&
    x**8 + 4095.0*x**10 - x**12)*Cos(x))/x**13 + (91*(86877511875.0 - 41701205700.0*x**2 + 2770007625*&
    x**4 - 57558600.0*x**6 + 454410.0*x**8 - 1320.0*x**10 + x**12)*Sin(x))/x**14

else if (L==14) then
    bessel=(-105*(2032933777875.0 - 301175374500.0*x**2 + 11043097065.0*x**4 - 149652360.0*x**6 + 831402*&
    x**8 - 1768.0*x**10 + x**12)*Cos(x))/x**14 + ((213458046676875.0 - 102776096548125.0*x**2 + &
    6957151150950.0*x**4 - 151242416325.0*x**6 + 1309458150.0*x**8 - 4594590.0*x**10 + 5460.0*x**12 - x**14)*&
    Sin(x))/x**15

else if (L==15) then
    bessel=((-6190283353629375.0 + 924984868933125.0*x**2 - 34785755754750.0*x**4 + 496939367925*&
    x**6 - 3055402350.0*x**8 + 7936110.0*x**10 - 7140.0*x**12 + x**14)*Cos(x))/x**15 - (15*&
    (-412685556908625.0 + 199227510231750.0*x**2 - 13703479539750.0*x**4 + 309206717820.0*x**6 - &
    2880807930.0*x**8 + 11639628.0*x**10 - 18564.0*x**12 + 8.0*x**14)*Sin(x))/x**16

    else if (L>15) then
        bessel = 1E-30
    end if

end function bessel

function bessel2(L,x)

! =========================================================
! Name:    function bessel2
!
! Purpose: calculating Spherical Bessel functions of the 
!          second kind, y_L(x)
!
! Input:   L    -> the order of the function
!          X    -> the argument of the function
! 
! Output:  bessel2 -> the spherical Bessel function of the
!                    second kind of order L and argument X
!
! Calls:   N/A
! =========================================================

    integer :: L
    doubleprecision :: bessel2, x
    
if (L==0) then
    bessel2=-(Cos(x)/x)

else if (L==1) then
    bessel2=-(Cos(x)/x**2) - Sin(x)/x

else if (L==2) then
    bessel2=((-3 + x**2)*Cos(x))/x**3 - (3*Sin(x))/x**2

else if (L==3) then
    bessel2=(3*(-5 + 2.0*x**2)*Cos(x))/x**4 + ((-15 + x**2)*Sin(x))/x**3

else if (L==4) then
    bessel2=((-105 + 45.0*x**2 - x**4)*Cos(x))/x**5 + (5*(-21 + 2.0*x**2)*Sin(x))/x**4

else if (L==5) then
    bessel2=(-15*(63 - 28.0*x**2 + x**4)*Cos(x))/x**6 + ((-945 + 105.0*x**2 - x**4)*Sin(x))/&
    x**5

else if (L==6) then
    bessel2=((-10395.0 + 4725.0*x**2 - 210.0*x**4 + x**6)*Cos(x))/x**7 - (21*(495 - 60.0*x**2 +&
     x**4)*Sin(x))/x**6

else if (L==7) then
    bessel2=(7*(-19305.0 + 8910.0*x**2 - 450.0*x**4 + 4.0*x**6)*Cos(x))/x**8 + ((-135135.0 + &
    17325.0*x**2 - 378.0*x**4 + x**6)*Sin(x))/x**7

else if (L==8) then
    bessel2=((-2027025.0 + 945945.0*x**2 - 51975.0*x**4 + 630.0*x**6 - x**8)*Cos(x))/x**9 + &
    (9*(-225225.0 + 30030.0*x**2 - 770.0*x**4 + 4.0*x**6)*Sin(x))/x**8

else if (L==9) then
    bessel2=(-45*(765765.0 - 360360.0*x**2 + 21021.0*x**4 - 308.0*x**6 + x**8)*Cos(x))/x**10 +&
     ((-34459425.0 + 4729725.0*x**2 - 135135.0*x**4 + 990.0*x**6 - x**8)*Sin(x))/x**9

else if (L==10) then
    bessel2=((-654729075.0 + 310134825.0*x**2 - 18918900.0*x**4 + 315315.0*x**6 - 1485.0*x**8 + &
    x**10)*Cos(x))/x**11 - (55*(11904165.0 - 1670760.0*x**2 + 51597.0*x**4 - 468.0*x**6 + x**8)*&
    Sin(x))/x**10

else if (L==11) then
    bessel2=(33*(-416645775.0 + 198402750.0*x**2 - 12530700.0*x**4 + 229320.0*x**6 - 1365.0*x**8 +&
     2.0*x**10)*Cos(x))/x**12 + ((-13749310575.0 + 1964187225.0*x**2 - 64324260.0*x**4 + 675675.0*x**6 -&
      2145.0*x**8 + x**10)*Sin(x))/x**11

else if (L==12) then
    bessel2=((-316234143225.0 + 151242416325.0*x**2 - 9820936125.0*x**4 + 192972780.0*x**6 - &
    1351350.0*x**8 + 3003.0*x**10 - x**12)*Cos(x))/x**13 + (39*(-8108567775.0 + 1175154750.0*x**2 - &
    40291020.0*x**4 + 471240.0*x**6 - 1925.0*x**8 + 2.0*x**10)*Sin(x))/x**12

else if (L==13) then
    bessel2=(-91*(86877511875.0 - 41701205700.0*x**2 + 2770007625.0*x**4 - 57558600.0*x**6 +&
     454410.0*x**8 - 1320.0*x**10 + x**12)*Cos(x))/x**14 + ((-7905853580625.0 + 1159525191825.0*x**2 - &
     41247931725.0*x**4 + 523783260.0*x**6 - 2552550.0*x**8 + 4095.0*x**10 - x**12)*Sin(x))/x**13

else if (L==14) then
    bessel2=((-213458046676875.0 + 102776096548125.0*x**2 - 6957151150950.0*x**4 + 151242416325.0*x**6 - &
    1309458150.0*x**8 + 4594590.0*x**10 - 5460.0*x**12 + x**14)*Cos(x))/x**15 - (105*(2032933777875.0 - &
    301175374500.0*x**2 + 11043097065.0*x**4 - 149652360.0*x**6 + 831402.0*x**8 - 1768.0*x**10 + x**12)*&
    Sin(x))/x**14

else if (L==15) then
    bessel2=(15*(-412685556908625.0 + 199227510231750.0*x**2 - 13703479539750.0*x**4 + 309206717820.0*x**6 -&
     2880807930.0*x**8 + 11639628.0*x**10 - 18564.0*x**12 + 8.0*x**14)*Cos(x))/x**16 + ((-6190283353629375.0 + &
     924984868933125.0*x**2 - 34785755754750.0*x**4 + 496939367925.0*x**6 - 3055402350.0*x**8 + 7936110.0*x**10 - &
     7140.0*x**12 + x**14)*Sin(x))/x**15

else if (L==16) then
    bessel2=((-191898783962510625.0 + 92854250304440625.0*x**2 - 6474894082531875.0*x**4 + &
    150738274937250.0*x**6 - 1490818103775.0*x**8 + 6721885170.0*x**10 - 13226850.0*x**12 +&
     9180.0*x**14 - x**16)*Cos(x))/x**17 + (17*(-11288163762500625.0 + 1699293469623750.0*x**2 - &
     65293049571750.0*x**4 + 974390917500.0*x**6 - 6495939450.0*x**8 + 19606860.0*x**10 -&
      23940.0*x**12 + 8.0*x**14)*Sin(x))/x**16

else if (L==17) then
    bessel2=(-153*(41389933795835625.0 - 20067846688890000.0*x**2 + 1416077891353125.0*x**4 - &
    33855655333500.0*x**6 + 351863386875.0*x**8 - 1732250520.0*x**10 + 3993990.0*x**12 - &
    3800.0*x**14 + x**16)*Cos(x))/x**18 + ((-6332659870762850625.0 + 959493919812553125.0*x**2 - &
    37554385678684875.0*x**4 + 581419060472250.0*x**6 - 4141161399375.0*x**8 + 14054850810.0*x**10 -&
     21366450.0*x**12 + 11628.0*x**14 - x**16)*Sin(x))/x**17

else if (L==18) then
    bessel2=((-221643095476699771875.0 + 107655217802968460625.0*x**2 - 7675951358500425000.0*x**4 +&
     187771928393424375.0*x**6 - 2034966711652875.0*x**8 + 10767019638375.0*x**10 - 28109701620.0*x**12 + &
     33575850.0*x**14 - 14535.0*x**16 + x**18)*Cos(x))/x**19 - (171*(1296158453080115625.0 - &
     197509859516970000.0*x**2 + 7855505776243125.0*x**4 - 125495023153500.0*x**6 + 944475406875.0*x**8 -&
      3522519000.0*x**10 + 6322470.0*x**12 - 4760.0*x**14 + x**16)*Sin(x))/x**18

else if (L==19) then
    bessel2=(95*(-86324152975135700625.0 + 41995533879795746250.0*x**2 - 3021900850609641000.0*x**4 + &
    75412855451934000.0*x**6 - 847091406286125.0*x**8 + 4760156050650.0*x**10 - 13737824100.0*x**12 +&
     19509336.0*x**14 - 11781.0*x**16 + 2.0*x**18)*Cos(x))/x**20 + ((-8200794532637891559375.0 + &
     1255977541034632040625.0*x**2 - 50661278966102805000.0*x**4 + 831561397170879375.0*x**6 - &
     6557114959770375.0*x**8 + 26428139112375.0*x**10 - 54057118500.0*x**12 + 51482970.0*x**14 - &
     17955.0*x**16 + x**18)*Sin(x))/x**19

else if (L==20) then
    bessel2=((-319830986772877770815625.0 + 155815096120119939628125.0*x**2 - &
    11303797869311688365625.0*x**4 + 287080580807915895000.0*x**6 - 3326245588683517500.0*x**8 +&
     19671344879311125.0*x**10 - 61665657928875.0*x**12 + 100391791500.0*x**14 - &
     77224455.0*x**16 + 21945.0*x**18 - x**20)*Cos(x))/x**21 + (105*(-3046009397836931150625.0 +&
      468616830436450946250.0*x**2 - 19138705387194393000.0*x**4 + 321658914070494000.0*x**6 -&
       2639877451336125.0*x**8 + 11354311618650.0*x**10 - 25815032100.0*x**12 + 29418840.0*x**14 - &
       14421.0*x**16 + 2.0*x**18)*Sin(x))/x**20

else if (L==21) then
    bessel2=(-231*(56766538777870080534375.0 - 27690994525790283187500.0*x**2 +&
     2023572676884674540625.0*x**4 - 52196469237802890000.0*x**6 + 621386538545272500.0*x**8 - &
     3839821747398000.0*x**10 + 12902626839375.0*x**12 - 23468211000.0*x**14 + 21729825.0*x**16 - &
     8740.0*x**18 + x**20)*Cos(x))/x**22 + ((-13113070457687988603440625.0 + &
     2025596249561559215165625.0*x**2 - 83648104232906493905625.0*x**4 + 1435402904039579475000.0*x**6 -&
      12196233825172897500.0*x**8 + 55437426478058625.0*x**10 - 137561852302875.0*x**12 +&
       180705224700.0*x**14 - 113565375.0*x**16 + 26565.0*x**18 - x**20)*Sin(x))/x**21

else if (L==22) then
    bessel2=((-563862029680583509947946875.0 + 275374479611447760672253125.0*x**2 - &
    20255962495615592151656250.0*x**4 + 529771326808407794735625.0*x**6 - 6459313068178107637500.0*x**8 +&
     41467195005587851500.0*x**10 - 147833137274823000.0*x**12 + 294775397791875.0*x**14 - &
     316234143225.0*x**16 + 164038875.0*x**18 - 31878.0*x**20 + x**22)*Cos(x))/x**23 - &
     (253*(2228703674626812292284375.0 - 345535453430513533687500.0*x**2 + 14411356716248247380625.0*x**4 - &
     251904699365048730000.0*x**6 + 2206372491936112500.0*x**8 - 10517772612438000.0*x**10 +&
      28092341379375.0*x**12 - 41426494200.0*x**14 + 31511025.0*x**16 - 10500.0*x**18 + &
      x**20)*Sin(x))/x**22

else if (L==23) then
    bessel2=(69*(-367736106313424028226921875.0 + 179782096419896191577606250.0*x**2 - &
    13303114957074771046968750.0*x**4 + 352277608619401602637500.0*x**6 - 4387340180607932047500.0*x**8 + &
    29124116893556685000.0*x**10 - 109267971029217000.0*x**12 + 235440575370000.0*x**14 - &
    284807147625.0*x**16 + 179729550.0*x**18 - 50050.0*x**20 + 4.0*x**22)*Cos(x))/x**24 + &
    ((-25373791335626257947657609375.0 + 3947034207764084569635628125.0*x**2 -&
     166098892464047855643581250.0*x**4 + 2951583106503986284955625.0*x**6 - &
     26554953724732220287500.0*x**8 + 131941075017779527500.0*x**10 - 375268733082243000.0*x**12 +&
      609202488769875.0*x**14 - 539458244325.0*x**16 + 233107875.0*x**18 - 37950.0*x**20 + &
      x**22)*Sin(x))/x**23

else if (L==24) then
    bessel2=((-1192568192774434123539907640625.0 + 583597200719403932796125015625.0*x**2 - &
    43417376285404930265991909375.0*x**4 + 1162692247248334989505068750.0*x**6 - &
    14757915532519931424778125.0*x**8 + 100908824153982437092500.0*x**10 - 395823225053338582500.0*x**12 +&
     911366923199733000.0*x**14 - 1218404977539750.0*x**16 + 899097073875.0*x**18 -&
      326351025.0*x**20 + 44850.0*x**22 - x**24)*Cos(x))/x**25 + (75*(-15900909236992454980532101875.0 +&
       2480992930594567443770966250.0*x**2 - 105254245540375588523616750.0*x**4 + &
       1898273056731975493069500.0*x**6 - 17490862853356955762700.0*x**8 + 90125903550606323400.0*x**10 -&
        270648359010829800.0*x**12 + 476531724548880.0*x**14 - 477805873545.0*x**16 + &
        252378126.0*x**18 - 59202.0*x**20 + 4.0*x**22)*Sin(x))/x**24

else if (L==25) then
    bessel2=(-325*(179802589064453144779862998125.0 - 88066574235650519892177795000.0*x**2 +&
     6584173546577890523853718125.0*x**4 - 178122569376020226732274500.0*x**6 + &
     2299830818732970308911125.0*x**8 - 16145411864637189934800.0*x**10 + 65861237210058467100.0*x**12 - &
     160604520731701200.0*x**14 + 233683826461470.0*x**16 - 196022922480.0*x**18 + &
     87361659.0*x**20 - 17388.0*x**22 + x**24)*Cos(x))/x**26 + ((-58435841445947272053455474390625.0 +&
      9143022811270661613805958578125.0*x**2 - 390756386568644372393927184375.0*x**4 +&
       7142252375954057792673993750.0*x**6 - 67230504092590798712878125.0*x**8 + &
       357767649273210458782500.0*x**10 - 1126573794382579042500.0*x**12 + 2126522820799377000.0*x**14 - &
       2365139074047750.0*x**16 + 1466947857375.0*x**18 - 450675225.0*x**20 + 52650.0*x**22 - &
       x**24)*Sin(x))/x**25

else if (L==26) then
    bessel2=((-2980227913743310874726229193921875.0 + 1460896036148681801336386859765625.0*x**2 - &
    109716273735247939365671502937500.0*x**4 + 2995798963692940188353441746875.0*x**6 - &
    39282388067747317859706965625.0*x**8 + 282368117188881354594088125.0*x**10 - &
    1192558830910701529275000.0*x**12 + 3057843156181285972500.0*x**14 - 4784676346798598250.0*x**16 +&
     4467484917645750.0*x**18 - 2347116571800.0*x**20 + 614557125.0*x**22 - 61425.0*x**24 +&
      x**26)*Cos(x))/x**27 - (351*(8490677816932509614604641578125.0 - 1331871030107060331702688875000.0*x**2 + &
      57306695683177936040949028125.0*x**4 - 1060253389142977540073062500.0*x**6 +&
       10174148683695239020903125.0*x**8 - 55720697512636766610000.0*x**10 + 182947881139051297500.0*x**12 - &
       366812794263762000.0*x**14 + 445475704038750.0*x**16 - 315241542000.0*x**18 + &
       119409675.0*x**20 - 20300.0*x**22 + x**24)*Sin(x))/x**26

else if (L==27) then
    bessel2=(189*(-835725287980928446351799721046875.0 + 409978443160455464248052693343750.0*x**2 - &
    30918434627485329128812420312500.0*x**4 + 851413764435786478322671275000.0*x**6 - &
    11321991548348224445780203125.0*x**8 + 83137329243909667427951250.0*x**10 - &
    362184533832138982965000.0*x**12 + 970743859105170150000.0*x**14 - 1617906431841950250.0*x**16 +&
     1654624043572500.0*x**18 - 995262582600.0*x**20 + 322561200.0*x**22 - 47125.0*x**24 + &
     2.0*x**26)*Cos(x))/x**28 + ((-157952079428395476360490147277859375.0 + &
     24835232614527590622718576616015625.0*x**2 - 1075219482605429805783580728787500.0*x**4 + &
     20114650184795455550373108871875.0*x**6 - 196411940338736589298534828125.0*x**8 +&
      1103802639920172567958708125.0*x**10 - 3761147082102981746175000.0*x**12 +&
       7950392206071343528500.0*x**14 - 10413707343032243250.0*x**16 + 8229577479873750.0*x**18 - &
       3688326041400.0*x**20 + 828316125.0*x**22 - 71253.0*x**24 + x**26)*Sin(x))/x**27

else if (L==28) then
    bessel2=((-8687364368561751199826958100282265625.0 + 4264706144566677861733233976502203125.0*x**2 - &
    322858023988858678095341496008203125.0*x**4 + 8960162355045248381529839406562500.0*x**6 -&
     120687901108772733302238653231250.0*x**8 + 903494925558188310773260209375.0*x**10 - &
     4047276346373966082515263125.0*x**12 + 11283441246308945238525000.0*x**14 - &
     19875980515178358821250.0*x**16 + 21984493279734735750.0*x**18 - 14813239463772750.0*x**20 + &
     5700140245800.0*x**22 - 1104421500.0*x**24 + 82215.0*x**26 - x**28)*Cos(x))/x**29 + &
     (203*(-42794898367299266994221468474296875.0 + 6743438530604732980907625335343750.0*x**2 - &
     293618513669291711795687605312500.0*x**4 + 5548869016495298082861547275000.0*x**6 -&
      55048303735072401615689953125.0*x**8 + 316651583170376946473231250.0*x**10 - &
      1115374651933987690245000.0*x**12 + 2470375751791777830000.0*x**14 - 3455690614055930250.0*x**16 + &
      2999944500052500.0*x**18 - 1544372973000.0*x**20 + 430887600.0*x**22 - 54405.0*x**24 + &
      2.0*x**26)*Sin(x))/x**28

else if (L==29) then
    bessel2=(-435*(1138344296570160502046291061416296875.0 - &
    559186671999377088724493854730812500.0*x**2 + 42483662742809817779718039612665625.0*x**4 - &
    1187523766395802034373669870375000.0*x**6 + 16184201298111286075012846218750.0*x**8 -&
     123308200366562179619145495000.0*x**10 + 566454498782563204246558125.0*x**12 - &
     1635882822836515279026000.0*x**14 + 3026210295944927841750.0*x**16 - 3583679155317261000.0*x**18 + &
     2659950790046550.0*x**20 - 1179339361200.0*x**22 + 284864580.0*x**24 - 31248.0*x**26 +&
      x**28)*Cos(x))/x**30 + ((-495179769008019818390136611716089140625.0 +&
       78186279317055760798442622902540390625.0*x**2 - 3422295054281901987810619857686953125.0*x**4 +&
        65281182872472523922574544247812500.0*x**6 - 657078572703318214645521556481250.0*x**8 + &
        3860387409203168236940293621875.0*x**10 - 14009802737448344131783603125.0*x**12 + &
        32345864906085643017105000.0*x**14 - 47936188301312512451250.0*x**16 + 45126065153139720750.0*x**18 - &
        26099517150456750.0*x**20 + 8674126461000.0*x**22 - 1457836380.0*x**24 + 94395.0*x**26 - &
        x**28)*Sin(x))/x**29

else if (L==30) then
    bessel2=((-29215606371473169285018060091249259296875.0 + 14360213301232574733313961739766585078125.0*x**2 - &
    1094607910438780651178196720635565468750.0*x**4 + 30800655488537117890295578719182578125.0*x**6 -&
     424327688671071405496734537610781250.0*x**8 + 3285392863516591073227607782406250.0*x**10 - &
     15441549636812672947761174487500.0*x**12 + 46032208994473130718717553125.0*x**14 -&
      88951128491735518297038750.0*x**16 + 111851106036395862386250.0*x**18 - &
      90252130306279441500.0*x**20 + 45080984168970750.0*x**22 - 13011189691500.0*x**24 + &
      1906401420.0*x**26 - 107880.0*x**28 + x**30)*Cos(x))/x**31 - &
      (465*(62829261013920794161329161486557546875.0 - 9939092137795379867328906901828312500.0*x**2 + &
      437170594030849415217098536659365625.0*x**4 - 8411170640324183072960048805375000.0*x**6 + &
      85793669246977032634207883718750.0*x**8 - 513844436131627147327876095000.0*x**10 +&
       1915825016974277040665158125.0*x**12 - 4591025986670220299202000.0*x**14 + &
       7160691155679933621750.0*x**16 - 7234286104706661000.0*x**18 + 4621204828790550.0*x**20 -&
        1774798225200.0*x**22 + 373080708.0*x**24 - 35728.0*x**26 + x**28)*Sin(x))/x**30

    end if

end function bessel2

function kronecker(A, B)

! =========================================================
! Name:    function kronecker
!
! Purpose: calculating the Kronecker delta function
!
! Input:   A, B   -> the arguments of the function
! 
! Output:  kronecker -> the value of the Kronecker delta
!                        function for arguments A and B
!
! Calls:   N/A
! =========================================================

    implicit none

    integer :: A, B, kronecker

    if(A - B == 0) then
        kronecker = 1
    else
        kronecker = 0
    end if

end function

integer function factorial(N)

! =========================================================
! Name:    function factorial
!
! Purpose: calculating N factorial, N!
!
! Input:   N    -> the argument of the function
! 
! Output:  factorial -> the value of N factorial, N!
!
! Calls:   N/A
! =========================================================

    implicit none
    
    integer :: N, i, ans
    ans = 1

    do i = 1, N
        ans = ans * i
    end do

    factorial = ans

end function

function piF(L,M)

! =========================================================
! Name:    function piF
!
! Purpose: calculating the function piF, used in calculating
!           Mie coefficients
!
! Input:   L, M   -> the orders of the function
! 
! Output:  piF -> the value of piF of order L,M
!
! Calls:   function kronecker
! =========================================================

    implicit none
    
    integer :: L, M, kronecker
    complex*16 :: piF, i, p1, p2, p3, p4, p5, ex

    i = complex(0,1)
    p1 = -0.5
    p2 = i ** (M + 1)
    p3 = kronecker(abs(M), 1)
    ex = (M + 1) / 2.0
    p4 = L * (L + 1)
    p5 = p4 ** ex

    piF = p1 * p2 * p3 * p5

end function

function tauF(L,M)

! =========================================================
! Name:    function tauF
!
! Purpose: calculating the function tauF, used in calculating
!           Mie coefficients
!
! Input:   L, M   -> the orders of the function
! 
! Output:  tauF -> the value of tauF of order L,M
!
! Calls:   function kronecker
! =========================================================

    implicit none
    
    integer :: L, M, kronecker, abM
    integer, parameter :: one = 1
    doubleprecision :: tauF, p1, p2, p3, ex, p4

    p1 = -0.5
    abM = abs(M)
    p2 = kronecker(abM,one)
    ex = (M + one) / 2.0
    p3 = L * (L + one)
    p4 = p3 ** ex

    tauF = p1 * p2 * p4

end function

function qlm(y,L,M)

! =========================================================
! Name:    function qlm
!
! Purpose: calculating the Mie coefficient q_lm
!
! Input:   y     -> a measure of polarization of the
!                   incident light
!          L, M  -> the order of the function
! 
! Output:  qlm   -> the value of coefficient plm of polarization
!                   y and order L, M
!
! Calls:   function factorial, function piF, function tauF
! =========================================================

    implicit none
    !Loses accuracy after L = 9

    integer :: L, M, factorial
    doubleprecision :: y, tauF
    complex*16 :: qlm, i, piF

    integer ::  p4, p5
    doubleprecision :: p6, c2, p2, p3
    complex*16 :: p1, c1, p7, p8, c3
    i = complex(0,1)

    p1 = i ** L
    c1 = p1
    
    
!    p2 = factorial(L - M)
 !   p3 = factorial(L + M)
  !  p4 = p2 * (2 * L + 1)
   ! p5 = L * (L + 1) * p3
    !p6 = real(p4) / real(p5)
    !c2 = p6
    
    if(M == 1) then
        p2 = 1.0 / real((L * L))
        p3 = 1.0 / real(((1 + L) * (1 + L)))
        p6 = p2 - p3
    else if (M == -1) then
        p6 = 1 + (2 * L) 
    end if
    
    c2 = p6
    
    p7 = pif(L,M) * sin(y)
    p8 = i * tauF(L,M) * cos(y)
    c3 = p7 + p8

    qlm = c1 * c2 * c3

end function

function plm(y, L, M)

! =========================================================
! Name:    function plm
!
! Purpose: calculating the Mie coefficient p_lm
!
! Input:   y    -> a measure of polarization of the
!                  incident light
!          L, M -> the order of the function
! 
! Output:  plm  -> the value of coefficient plm of polarization
!                  y and order L, M
!
! Calls:   function factorial, function piF, function tauF
! =========================================================

    implicit none
    !Accurate through L = 30
    !Works
    
    integer :: L, M, factorial
    doubleprecision :: y, tauF
    complex*16 :: plm, i, piF

    complex*16 :: p1, p8, p9
    integer :: p4, p5
    doubleprecision :: p6, p7, p2, p3

    complex*16 :: c1, c3
    doubleprecision :: c2
    i = complex(0,1)

    p1 = (i ** L) * (-1)
    c1 = p1 
    
!    p2 = factorial(L - M)
 !   p3 = factorial(L + M)
  !  p4 = (2 * L + 1) * p2
   ! p5 = L * (L + 1) * p3
    !p6 = real(p4) / real(p5)
    !c2 = p6
    
    if(M == 1) then
        p2 = 1.0 / real((L * L))
        p3 = 1.0 / real(((1 + L) * (1 + L)))
        p6 = p2 - p3
    else if (M == -1) then
        p6 = 1 + (2 * L) 
    end if
    
    c2 = p6
    
    p7 = tauF(L,M) * sin(y)
    p8 = piF(L,M) * cos(y) * i
    p9 = p7 + p8
    c3 = p9

    plm = c1 * c2 * c3

end function

function besselDerivative(N, X)

! =========================================================
! Name:    function besselDerivative
!
! Purpose: calculating derivative of the spherical Bessel
!          function, j_l(kr), with respect to r
!
! Input:   N     -> the order of the function
!          X     -> the argument of the function
! 
! Output:  besselDerivative  -> the value of the derivative
!                               of the spherical Bessel
!                               function, evaluated at order
!                               N and argument X
!
! Calls:   function bessel
! =========================================================

    implicit none
    
    doubleprecision :: X, besselDerivative, bessel, p1, p2
    integer :: N

    p1 = x * bessel(N - 1, X)
    p2 = N * bessel(N, X)

    besselDerivative = p1 - p2

end function

function hankelDerivative(N, X)

! =========================================================
! Name:    function hankelDerivative
!
! Purpose: calculating derivative of the spherical Hankel
!          function, h_l(kr), with respect to r
!
! Input:   N    -> the order of the function
!          X    -> the argument of the function
! 
! Output:  hankelDerivative  -> the value of the derivative
!                               of the spherical Hankel
!                               function, evaluated at order
!                               N and argument X
!
! Calls:   function hankel
! =========================================================

    implicit none
    
    doubleprecision :: X
    complex*16 :: hankelDerivative, hankel, p1, p2
    integer :: N

    p1 = x * hankel(N-1, X)
    p2 = N * hankel(N,X)

    hankelDerivative = p1 - p2

end function

function alm(L, M, k0, a, y, et)

! =========================================================
! Name:    function alm
!
! Purpose: calculating the Mie scattering coefficient a_lm
!
! Input:   
!           L, M  -> the order of the function
!           k0    -> wave number, 2pi / wavelength
!           a     -> radius of the sphere
!           y     -> a measure of polarization of the
!                    incident light
!           et    -> tangential permittivity
! 
! Output:  alm -> the value of coefficient alm
!
! Calls:   function bessel, function hankel, function
!          besselDerivative, function hankelDerivative,
!          function plm
! =========================================================

    implicit none

    integer :: L, M, v
    doubleprecision :: besselDerivative, bessel, k0, a, y, et
    complex*16 :: alm, hankelDerivative, plm, hankel

    complex*16 :: c1, p1, p2, c2, p3, p4, c3
    doubleprecision :: DJarg
    DJarg = k0 * sqrt(et) * a 

        c1 = plm(y,L,M)
    p1 = bessel(L, k0 * a) * (1 / et) * besselDerivative(L, DJarg) !Works
    p2 = bessel(L, DJarg) * besselDerivative(L, k0 * a) !Works
        c2 = p1 - p2
    p3 = bessel(L, DJarg) * hankelDerivative(L, k0 * a) !Works with L = 1 workaround
    p4 = hankel(L, k0 * a) * (1 / et) * besselDerivative(L, DJarg)
        c3 = p3 - p4

    alm = c1 * (c2 / c3)

end function

function blm(L, M, k0, a, y, et)

! =========================================================
! Name:    function blm
!
! Purpose: calculating the Mie scattering coefficient b_lm
!
! Input:   
!           L, M  -> the order of the function
!           k0    -> wave number, 2pi / wavelength
!           a     -> radius of the sphere
!           y     -> a measure of polarization of the
!                    incident light
!           et    -> tangential permittivity
! 
! Output:  blm -> the value of coefficient blm
!
! Calls:   function bessel, function hankel, function
!           besselDerivative, function hankelDerivative,
!             function qlm
! =========================================================

    implicit none

    !Functions
    integer :: L, M, v
    doubleprecision :: besselDerivative, bessel, k0, a, y, et
    complex*16 :: blm, hankelDerivative, qlm, hankel

    !Parts
    complex*16 :: c1, p1, p2, c2, p3, p4, c3
    doubleprecision :: DJarg

    DJarg = k0 * sqrt(et) * a !3459.768
    v = L

        c1 = qlm(y,L,M)
    p1 = bessel(L, k0 * a) * besselDerivative(L , DJarg) !Works
    p2 = bessel(L, DJarg) * besselDerivative(L, k0 * a) !Works
        c2 = p1 - p2
    p3 = bessel(L, DJarg) * hankelDerivative(L, k0 * a)
    p4 = hankel(L, k0 * a) * besselDerivative(L, DJarg)
        c3 = p3 - p4

    blm = c1 * (c2 / c3)

end function

function psi(k,r,L,M,theta,phi)

! =========================================================
! Name:    function psi
!
! Purpose: calculating the first scalar potential psi, a 
!          solution to the scalar wave equation
!
! Input:   
!           L, M  -> the order of the function
!           k     -> wave number, 2pi / wavelength
!           r     -> radial coordinate
!           theta -> angular coordinate
!           phi   -> angular coordinate
! 
! Output:  psi     -> value of the scalar potential psi
!
! Calls:   function bessel, function legendre
! =========================================================

    implicit none

    integer :: L, M
    doubleprecision :: legendre, bessel, k, r, theta, phi
    complex*16 :: psi, p1, p2, p3, p4, i
    i = CMPLX(0,1)

    p1 = bessel(L, k * r)
    p2 = legendre(L,M,cos(theta))
    p3 = exp(i * M * phi)
    p4 = (-1) ** M

    psi = p1 * p2 * p3 * p4

end function

recursive function legendre(L, M, x) result(legValue)

! =========================================================
! Name:    function legendre
!
! Purpose: calculating Associated Legendre Polynomials,
!            P_L^M(x)
!
! Input:   L, M  -> the order of the polynomial
!          X     -> the real part of the argument
! 
! Output:  legValue -> the associated Legendre polynomial
!                      of order L, M and argument X
!
! Calls: function factorial
! =========================================================

    implicit none
    integer :: L, M, factorial
    doubleprecision :: x, legValue
    !x = cos(theta)
    !Works great but less accuracy when using recursion

    if(M == 1) then
    
        if(L == 0) then
            legValue = 0.0
        else if(L == 1) then
            legValue =  -Sqrt(1 - x**2)
        else if(L == 2) then
            legValue =  -3 * x * sqrt(1 - x**2)
        else if(L == 3) then
            legValue =  (-3 * sqrt(1 - x**2) * (-1 + 5 * x**2))/ 2   
        else if(L == 4) then
            legValue =  (-5 * sqrt(1 - x**2) * ((-3 * x) + 7 * x**3))/ 2 
        else if(L == 5) then
            legValue =  (-15*sqrt(1 - x**2)*(1 - 14*x**2 + 21*x**4))/8
        else if(L == 6) then
            legValue =  (-21*Sqrt(1 - x**2)*(5*x - 30*x**3 + 33*x**5))/8
        else if(L == 7) then
            legValue =  (-7*Sqrt(1 - x**2)*(-5 + 135*x**2 - 495*x**4 + 429*x**6))/16
        else if(L == 8) then 
            legValue =  (-9*Sqrt(1 - x**2)*(-35*x + 385*x**3 - 1001*x**5 + 715*x**7))/16
        else if(L == 9) then
            legValue =  (-45*Sqrt(1 - x**2)*(7 - 308*x**2 + 2002*x**4 - 4004*x**6 + 2431*x**8))/128
        else if(L == 10) then
            legValue =  (-55*Sqrt(1 - x**2)*(63*x - 1092*x**3 + 4914*x**5 - 7956*x**7 + 4199*x**9))/128
        else if(L == 11) then
            legValue =  (-33*Sqrt(1 - x)*Sqrt(1 + x)*(-21 + 1365*x**2 - 13650*x**4 + 46410*x**6 - 62985*x**8 + 29393*x**10))/256
        else if(L == 12) then
            legValue =  (-39*Sqrt(1 - x)*Sqrt(1 + x)*(-231*x + 5775*x**3 - 39270*x**5 + 106590*x**7 - 124355*x**9 + 52003*x**11))&
                /256
        else if(L == 13) then 
            legValue =  (-91*Sqrt(1 - x)*Sqrt(1 + x)*&
                (33 - 2970*x**2 + 42075*x**4 - 213180*x**6 + 479655*x**8 - 490314*x**10 + 185725*x**12))/1024
        else if(L == 14) then
            legValue =  (-105*Sqrt(1 - x)*Sqrt(1 + x)*&
                (429*x - 14586*x**3 + 138567*x**5 - 554268*x**7 + 1062347*x**9 - 965770*x**11 + 334305*x**13))&
                /1024
        else if(L == 15) then
            legValue =  (-15*Sqrt(1 - x)*Sqrt(1 + x)*(-429 + 51051*x**2 - 969969*x**4 + &
                6789783*x**6 - 22309287*x**8 + 37182145*x**10 - 30421755*x**12 + 9694845*x**14))/2048
        else if(L == 16) then
            legValue =  (-17*Sqrt(1 - x)*Sqrt(1 + x)*(-6435*x + 285285*x**3 - 3594591*x**5 + &
                19684665*x**7 - 54679625*x**9 + 80528175*x**11 - 59879925*x**13 + &
                17678835*x**15))/2048
        else if(L == 17) then
            legValue =  (-153*Sqrt(1 - x)*Sqrt(1 + x)*(715 - 108680*x**2 + 2662660*x**4 - &
                24496472*x**6 + 109359250*x**8 - 262462200*x**10 + 345972900*x**12 - &
                235717800*x**14 + 64822395*x**16))/32768
        else if(L == 18) then
            legValue =  (-171*Sqrt(1 - x)*Sqrt(1 + x)*(12155*x - 680680*x**3 + 10958948*x**5 &
                - 78278200*x**7 + 293543250*x**9 - 619109400*x**11 + 738168900*x**13 &
                - 463991880*x**15 + 119409675*x**17))/32768
        else if(L == 19) then
            legValue =  (-95*Sqrt(1 - x)*Sqrt(1 + x)*(-2431 + 459459*x**2 - 14090076*x**4 + &
                164384220*x**6 - 951080130*x**8 + 3064591530*x**10 - 5757717420*x**12 &
                + 6263890380*x**14 - 3653936055*x**16 + 883631595*x**18))/65536
        else if(L == 20) then
            legValue =  (-105*Sqrt(1 - x)*Sqrt(1 + x)*(-46189*x + 3187041*x**3 - &
                63740820*x**5 + 573667380*x**7 - 2772725670*x**9 + 7814045070*x**11 - &
                13223768580*x**13 + 13223768580*x**15 - 7195285845*x**17 + &
                1641030105*x**19))/65536
        else if(L == 21) then
            legValue =  (-231*Sqrt(1 - x)*Sqrt(1 + x)*(4199 - 965770*x**2 + 36216375*x**4 - &
                521515800*x**6 + 3780989550*x**8 - 15628090140*x**10 + &
                39070225350*x**12 - 60108039000*x**14 + 55599936075*x**16 - &
                28345065450*x**18 + 6116566755*x**20))/262144
        else if(L == 22) then
            legValue =  (-253*Sqrt(1 - x)*Sqrt(1 + x)*(88179*x - 7348250*x**3 + &
                178562475*x**5 - 1972690200*x**7 + 11890938150*x**9 - &
                42807377340*x**11 + 96042192750*x**13 - 135373757400*x**15 + &
                116461247175*x**17 - 55846913850*x**19 + 11435320455*x**21))/262144
        else if(L == 23) then
            legValue =  (-69*Sqrt(1 - x)*Sqrt(1 + x)*(-29393 + 8083075*x**2 - 363738375*x**4 &
                + 6329047725*x**6 - 56057279850*x**8 + 287760703230*x**10 - &
                915602237550*x**12 + 1861389164250*x**14 - 2419805913525*x**16 + &
                1945334165775*x**18 - 880519675035*x**20 + 171529806825*x**22))/524288
        else if(L == 24) then
            legValue =  (-75*Sqrt(1 - x)*Sqrt(1 + x)*(-676039*x + 66927861*x**3 - &
                1940907969*x**5 + 25786348731*x**7 - 189099890694*x**9 + &
                842354058546*x**11 - 2397469243554*x**13 + 4452442880886*x**15 - &
                5369122297539*x**17 + 4050390505161*x**19 - 1735881645069*x**21 + &
                322476036831*x**23))/524288
        else if(L == 25) then
            legValue =  (-325*Sqrt(1 - x)*Sqrt(1 + x)*(52003 - 16848972*x**2 + 895803678*x**4 &
                - 18513276012*x**6 + 196372963413*x**8 - 1221876216792*x**10 + &
                4794938487108*x**12 - 12329841823992*x**14 + 21063479782653*x**16 - &
                23679206030172*x**18 + 16824699021438*x**20 - 6846414320412*x**22 + &
                1215486600363*x**24))/4.194304e6
        else if(L == 26) then
            legValue =  (-351*Sqrt(1 - x)*Sqrt(1 + x)*(1300075*x - 150808700*x**3 + &
                5142576670*x**5 - 80811919100*x**7 + 707104292125*x**9 - &
                3805506735800*x**11 + 13319273575300*x**13 - 31205155233560*x**15 + &
                49331679229525*x**17 - 51928083399500*x**19 + 34865998853950*x**21 - &
                13505406670700*x**23 + 2295919134019*x**25))/4.194304e6
        else if(L == 27) then 
            legValue =  (-189*Sqrt(1 - x)*Sqrt(1 + x)*(-185725 + 70018325*x**2 - &
                4341136150*x**4 + 105055494830*x**6 - 1313193685375*x**8 + &
                9717633271775*x**10 - 45937902739300*x**12 + 144881077870100*x**14 - &
                311494317420715*x**16 + 458079878559875*x**18 - 453257985101350*x**20 &
                + 288436899609950*x**22 - 106596245508025*x**24 + &
                17383387729001*x**26))/8.388608e6
        else if(L == 28) then
            legValue =  (-203*Sqrt(1 - x)*Sqrt(1 + x)*(-5014575*x + 673624575*x**3 - &
                26675533170*x**5 + 489051441450*x**7 - 5026362037125*x**9 + &
                32077328636925*x**11 - 134889279396300*x**13 + 386682600936060*x**15 &
                - 767678693034825*x**17 + 1054997034287625*x**19 - &
                984663898668450*x**21 + 595468681803450*x**23 - 210398934237219*x**25 &
                + 32968493968795*x**27))/8.388608e6
        else if(L == 29) then
            legValue =  (-435*Sqrt(1 - x)*Sqrt(1 + x)*(334305 - 145088370*x**2 + &
                10373818455*x**4 - 290466916740*x**6 + 4222144111185*x**8 - &
                36591915630270*x**10 + 204582073751055*x**12 - 773365201872120*x**14 &
                + 2030083654914315*x**16 - 3741722814940110*x**18 + &
                4824853103475405*x**20 - 4260909234238020*x**22 + &
                2454654232767555*x**24 - 830806048013634*x**26 + &
                125280277081421*x**28))/3.3554432e7
        else if(L == 30) then
            legValue =  (-465*Sqrt(1 - x)*Sqrt(1 + x)*(9694845*x - 1493006130*x**3 + &
                67931778915*x**5 - 1436271897060*x**7 + 17115573439965*x**9 - &
                127588820188830*x**11 + 633036838629195*x**13 - &
                2170412018157240*x**15 + 5250482014512735*x**17 - &
                9027144516179790*x**19 + 10961532626789745*x**21 - &
                9185157774226980*x**23 + 5051836775824839*x**25 - &
                1640767499840546*x**27 + 238436656380769*x**29))/3.3554432e7
        end if
        
    else if (M == -1) then
    
        if(L == 0) then
              legValue = Sqrt(1 - x)/Sqrt(1 + x)
          else if(L < 20) then
            legValue = -1 * (real(factorial(L - 1)) / factorial(L + 1)) * &
            legendre(L, 1, x) 
        else if(L == 20) then
            legValue = (Sqrt(1 - x)*Sqrt(1 + x)*(-46189*x + 3187041*x**3 - 63740820*x**5 + &
                573667380*x**7 - 2772725670*x**9 + 7814045070*x**11 - &
                13223768580*x**13 + 13223768580*x**15 - 7195285845*x**17 + &
                1641030105*x**19))/262144
        else if(L == 21) then
            legValue = (Sqrt(1 - x)*Sqrt(1 + x)*(4199 - 965770*x**2 + 36216375*x**4 - &
                521515800*x**6 + 3780989550*x**8 - 15628090140*x**10 + &
                39070225350*x**12 - 60108039000*x**14 + 55599936075*x**16 - &
                28345065450*x**18 + 6116566755*x**20))/524288
        else if(L == 22) then 
            legValue = (Sqrt(1 - x)*Sqrt(1 + x)*(88179*x - 7348250*x**3 + 178562475*x**5 - &
                1972690200*x**7 + 11890938150*x**9 - 42807377340*x**11 + &
                96042192750*x**13 - 135373757400*x**15 + 116461247175*x**17 - &
                55846913850*x**19 + 11435320455*x**21))/524288
        else if(L == 23) then
            legValue = (Sqrt(1 - x)*Sqrt(1 + x)*(-29393 + 8083075*x**2 - 363738375*x**4 + &
                6329047725*x**6 - 56057279850*x**8 + 287760703230*x**10 - &
                915602237550*x**12 + 1861389164250*x**14 - 2419805913525*x**16 + &
                1945334165775*x**18 - 880519675035*x**20 + &
                171529806825*x**22))/4.194304e6
        else if(L == 24) then 
            legValue = (Sqrt(1 - x)*Sqrt(1 + x)*(-676039*x + 66927861*x**3 - 1940907969*x**5 &
                + 25786348731*x**7 - 189099890694*x**9 + 842354058546*x**11 - &
                2397469243554*x**13 + 4452442880886*x**15 - 5369122297539*x**17 + &
                4050390505161*x**19 - 1735881645069*x**21 + &
                322476036831*x**23))/4.194304e6
        else if(L == 25) then 
            legValue = (Sqrt(1 - x)*Sqrt(1 + x)*(52003 - 16848972*x**2 + 895803678*x**4 - &
                18513276012*x**6 + 196372963413*x**8 - 1221876216792*x**10 + &
                4794938487108*x**12 - 12329841823992*x**14 + 21063479782653*x**16 - &
                23679206030172*x**18 + 16824699021438*x**20 - 6846414320412*x**22 + &
                1215486600363*x**24))/8.388608e6
        else if(L == 26) then
            legValue = (Sqrt(1 - x)*Sqrt(1 + x)*(1300075*x - 150808700*x**3 + &
                5142576670*x**5 - 80811919100*x**7 + 707104292125*x**9 - &
                3805506735800*x**11 + 13319273575300*x**13 - 31205155233560*x**15 + &
                49331679229525*x**17 - 51928083399500*x**19 + 34865998853950*x**21 - &
                13505406670700*x**23 + 2295919134019*x**25))/8.388608e6
        else if(L == 27) then
            legValue = (Sqrt(1 - x)*Sqrt(1 + x)*(-185725 + 70018325*x**2 - 4341136150*x**4 &
                + 105055494830*x**6 - 1313193685375*x**8 + 9717633271775*x**10 - &
                45937902739300*x**12 + 144881077870100*x**14 - 311494317420715*x**16 &
                + 458079878559875*x**18 - 453257985101350*x**20 + &
                288436899609950*x**22 - 106596245508025*x**24 + &
                17383387729001*x**26))/3.3554432e7
        else if(L == 28) then
            legValue = (Sqrt(1 - x)*Sqrt(1 + x)*(-5014575*x + 673624575*x**3 - &
                26675533170*x**5 + 489051441450*x**7 - 5026362037125*x**9 + &
                32077328636925*x**11 - 134889279396300*x**13 + 386682600936060*x**15 &
                - 767678693034825*x**17 + 1054997034287625*x**19 - &
                984663898668450*x**21 + 595468681803450*x**23 - 210398934237219*x**25 &
                + 32968493968795*x**27))/3.3554432e7
        else if(L == 29) then
            legValue = (Sqrt(1 - x)*Sqrt(1 + x)*(334305 - 145088370*x**2 + 10373818455*x**4 &
                - 290466916740*x**6 + 4222144111185*x**8 - 36591915630270*x**10 + &
                204582073751055*x**12 - 773365201872120*x**14 + &
                2030083654914315*x**16 - 3741722814940110*x**18 + &
                4824853103475405*x**20 - 4260909234238020*x**22 + &
                2454654232767555*x**24 - 830806048013634*x**26 + &
                125280277081421*x**28))/6.7108864e7
        else if(L == 30) then
            legValue = (Sqrt(1 - x)*Sqrt(1 + x)*(9694845*x - 1493006130*x**3 + &
                67931778915*x**5 - 1436271897060*x**7 + 17115573439965*x**9 - &
                127588820188830*x**11 + 633036838629195*x**13 - &
                2170412018157240*x**15 + 5250482014512735*x**17 - &
                9027144516179790*x**19 + 10961532626789745*x**21 - &
                9185157774226980*x**23 + 5051836775824839*x**25 - &
                1640767499840546*x**27 + 238436656380769*x**29))/6.7108864e7
        end if

    end if

end function

function psi2(k,r,L,M,theta,phi)

! =========================================================
! Name:    function psi2
!
! Purpose: calculating the second scalar potential psi, a 
!          solution to the scalar wave equation
!
! Input:   
!           L, M  -> the order of the function
!           k     -> wave number, 2pi / wavelength
!           r     -> radial coordinate
!           theta -> angular coordinate
!           phi   -> angular coordinate
! 
! Output:  psi2 -> value of the second scalar potential psi2
!
! Calls:   function hankel, function legendre
! =========================================================

    implicit none

    integer :: L, M
    doubleprecision :: k, r, theta, phi, legendre
    complex*16 :: psi2, hankel, i, p1, p2, p3, p4
    i = CMPLX(0,1)

    p1 = hankel(L, k * r)
    p2 = legendre(L,M,cos(theta))
    p3 = exp(i * M * phi)
    p4 = (-1) ** M

    psi2 = p1 * p2 * p3 * p4 * 1.0

end function

function DpsiDT(k,L,M,r,theta,phi)

! =========================================================
! Name:    function DpsiDT
!
! Purpose: calculating the derivative of the first scalar
!          potential function, psi, with respect to theta,
!          evaluated at the given inputs
!
! Input:   
!           L, M  -> the order of the function
!           k     -> wave number, 2pi / wavelength
!           r     -> radial coordinate
!           theta -> angular coordinate
!           phi   -> angular coordinate
! 
! Output:  DpsiDT -> value of the derivative of the first
!                    scalar potential function with respect
!                    to theta, evaluated at the inputs
!
! Calls:   function bessel, function legendre
! =========================================================

    implicit none

    integer :: L, M
    doubleprecision :: k, r, theta, phi, legendre, bessel
    complex*16 :: i, DpsiDT, p1, p2, p3, p4

    i = CMPLX(0,1)
    
    p1 = L * COS(theta) * legendre(L,M,COS(theta)) * 1.0
    p2 = (L+M) * legendre(L-1,M,COS(theta)) * 1.0
    p3 = ((p1 - p2) / (SIN(theta))) * 1.0
    p4 = ((-1.0)**M) * bessel(L,k*r) * EXP(i*M*phi) * 1.0
    DpsiDT = p3 * p4

    !DpsiDT = (((L*cos(theta)*legendre(L,M,cos(theta))) &
    !- ((L+M)*legendre(L-1,M,cos(theta)))) / sin(theta)) &
    !* ((-1)**M) * bessel(L,k*r) * exp(i*M*phi) * 1.0

end function

function DRpsiDR(k,v,L,M,r,theta,phi)

! =========================================================
! Name:    function DRpsiDR
!
! Purpose: calculating the derivative of the first scalar
!          potential function times r, r*psi, with respect to
!          r, evaluated at the given inputs
!
! Input:   
!           L, M  -> the order of the function
!           k     -> wave number, 2pi / wavelength
!           r     -> radial coordinate
!           theta -> angular coordinate
!           phi   -> angular coordinate
! 
! Output:  DRpsiDR -> value of the derivative of r times the 
!                     first scalar potential function with respect
!                     to r, evaluated at the inputs
!
! Calls:   function bessel, function legendre
! =========================================================

    implicit none

    integer :: L, M, v
    doubleprecision :: k, r, theta, phi, legendre, bessel
    complex*16 :: i, DRpsiDR

    i = CMPLX(0,1)

    DRpsiDR = ((k*r*bessel(v-1,k*r)) - (v*bessel(v,k*r))) &
    * ((-1)**M) * exp(i*M*phi) * legendre(L,M,cos(theta)) * 1.0

end function

function DR2psiDRDT(k,v,L,M,r,theta,phi)

! =========================================================
! Name:    function DR2psiDRDT
!
! Purpose: calculating the second derivative of the first scalar
!          potential function times r, r*psi, with respect to
!          r and then theta, evaluated at the given inputs
!
! Input:   
!           L, M -> the order of the function
!           k    -> wave number, 2pi / wavelength
!           r      -> radial coordinate
!           v     -> metamaterial order, not used for dielectric
!           theta -> angular coordinate
!           phi  -> angular coordinate
! 
! Output:  DR2psiDRDT -> value of the second derivative of r times the 
!                     first scalar potential function with respect
!                     to r and then theta, evaluated at the inputs
!
! Calls:   function bessel, function legendre
! =========================================================

    implicit none

    integer :: L, M, v
    doubleprecision :: k, r, theta, phi, legendre, bessel
    complex*16 :: i, DR2psiDRDT

    i = CMPLX(0,1)

    DR2psiDRDT = (((L*cos(theta)*legendre(L,M,cos(theta))) &
    - ((L+M)*legendre(L-1,M,cos(theta)))) / sin(theta)) &
    * ((k*r*bessel(v-1,k*r)) - (v*bessel(v,k*r))) &
    * ((-1)**M) * exp(i*M*phi) * 1.0

end function

function Dpsi2DT(k,v,L,M,r,theta,phi)

! =========================================================
! Name:    function Dpsi2DT
!
! Purpose: calculating the derivative of the second scalar
!          potential function, psi2, with respect to theta,
!          evaluated at the given inputs
!
! Input:   
!           L, M  -> the order of the function
!           k     -> wave number, 2pi / wavelength
!           r     -> radial coordinate
!           v     -> metamaterial order, not used for dielectric
!           theta -> angular coordinate
!           phi   -> angular coordinate
! 
! Output:  Dpsi2DT -> value of the derivative of the second
!                     scalar potential function with respect
!                     to theta, evaluated at the inputs
!
! Calls:   function hankel, function legendre
! =========================================================

    implicit none

    integer :: L, M, v
    doubleprecision :: k, r, theta, phi, legendre
    complex*16 :: i, hankel, Dpsi2DT

    i = CMPLX(0,1)

    Dpsi2DT = (((L*cos(theta)*legendre(L,M,cos(theta))) &
    - ((L+M)*legendre(L-1,M,cos(theta)))) / sin(theta)) &
    * ((-1)**M) * hankel(v,k*r) * exp(i*M*phi) * 1.0

end function

function DRpsi2DR(k,v,L,M,r,theta,phi)

! =========================================================
! Name:    function DRpsi2DR
!
! Purpose: calculating the derivative of the second scalar
!          potential function times r, r*psi2, with respect to
!          r, evaluated at the given inputs
!
! Input:   
!           L, M  -> the order of the function
!           k     -> wave number, 2pi / wavelength
!           r     -> radial coordinate
!           v     -> metamaterial order, not used for dielectric
!           theta -> angular coordinate
!           phi   -> angular coordinate
! 
! Output:  DRpsi2DR -> value of the derivative of r times the 
!                     second scalar potential function with respect
!                     to r, evaluated at the inputs
!
! Calls:   function hankel, function legendre
! =========================================================

    implicit none

    integer :: L, M, v
    doubleprecision :: k, r, theta, phi, legendre
    complex*16 :: i, DRpsi2DR, hankel

    i = CMPLX(0,1)

    DRpsi2DR = ((k*r*hankel(v-1,k*r)) - (v*hankel(v,k*r))) &
    * ((-1)**M) * exp(i*M*phi) * legendre(L,M,cos(theta)) * 1.0

end function

function DR2psi2DRDT(k,v,L,M,r,theta,phi)

! =========================================================
! Name:    function DR2psi2DRDT
!
! Purpose: calculating the second derivative of the first scalar
!          potential function times r, r*psi2, with respect to
!          r and then theta, evaluated at the given inputs
!
! Input:   
!           L, M  -> the order of the function
!           k     -> wave number, 2pi / wavelength
!           r     -> radial coordinate
!           v     -> metamaterial order, not used for dielectric
!           theta -> angular coordinate
!           phi   -> angular coordinate
! 
! Output:  DR2psi2DRDT -> value of the second derivative of r times the 
!                     first scalar potential function with respect
!                     to r and then theta, evaluated at the inputs
!
! Calls:   function hankel, function legendre
! =========================================================

    implicit none

    integer :: L, M, v
    doubleprecision :: k, r, theta, phi, legendre
    complex*16 :: i, DR2psi2DRDT, hankel

    i = CMPLX(0,1)

    DR2psi2DRDT = (((L*cos(theta)*legendre(L,M,cos(theta))) &
    - ((L+M)*legendre(L-1,M,cos(theta)))) / sin(theta)) &
    * ((k*r*hankel(v-1,k*r)) - (v*hankel(v,k*r))) &
    * ((-1)**M) * exp(i*M*phi) * 1.0

end function

subroutine convToSph(vectA,vectASph)

! =========================================================
! Name:    subroutine convToSph
!
! Purpose: converting a vector from Cartesian to spherical 
!		   coordinates
!
! Input:   vectA    -> input Cartesian vector    
! 
! Output:  vectASph -> output spherical vector
!
! Calls:   N/A
! =========================================================

    doubleprecision, dimension(1:3) :: vectA, vectASph
    
    vectASph(1) = sqrt((vectA(1)*vectA(1)) + (vectA(2)*vectA(2)) + (vectA(3)*vectA(3)))
    vectASph(3) = acos(vectA(3)/vectASph(1))
    vectASph(2) = asin(vectA(2) / (vectASph(1) * sin(vectASph(3))))

end subroutine

subroutine convToRect(vectA,vectARect)

! =========================================================
! Name:    subroutine convToRect
!
! Purpose: converting a vector from spherical to Cartesian 
!		   coordinates
!
! Input:   vectA    -> input spherical vector    
! 
! Output:  vectARect -> output Cartesian vector
!
! Calls:   N/A
! =========================================================

    doubleprecision, dimension(1:3) :: vectA, vectARect
    
    vectARect(1) = vectA(1)*sin(vectA(3))*cos(vectA(2))
    vectARect(2) = vectA(1)*sin(vectA(3))*sin(vectA(2))
    vectARect(3) = vectA(1)*cos(vectA(3))

end subroutine

subroutine Inside(k0,r,theta,phi,y,et,a1,lim,Ins)

! =========================================================
! Name:    subroutine Inside
!
! Purpose: calculating the electric field inside the sphere
!
! Input:   k0 		-> wavenumber
!		   r		-> radial coordinate
!		   theta  	-> angular coordinate
!		   phi		-> angular coordinate
!		   y		-> polarization measurement
!		   et		-> dielectric permittivity
!		   a1		-> sphere radius
!		   lim		-> upper limit on l sum
! 
! Output:  Ins		-> electric field vector inside sphere
!
! Calls:   UnitStep, Mvh, Nve
! =========================================================

    complex*16 :: m1, m2, m3, n1, n2, n3
    complex*16 :: sumM1, sumM2, sumM3, sumN1, sumN2, sumN3
    complex*16 :: clm, dlm
    integer :: L, M, lim
    doubleprecision :: k0, r, theta, phi, y, et, a1, UnitStep
    complex*16, dimension(1:3) :: Mvh, Nve, Ins
    
    sumM1 = 0.0
    sumM2 = 0.0
    sumM3 = 0.0
    
    sumN1 = 0.0
    sumN2 = 0.0
    sumN3 = 0.0
    
    do M = -1, 1, 2
        do L = 1, lim
        
            call MvhVector(k0 * sqrt(et),L,M,r,theta,phi,Mvh)
            call NveVector(k0,L,M,r,theta,phi,et,Nve)
            
            m1 = dlm(L, M, k0, a1, y, et) * Mvh(1)
            m2 = dlm(L, M, k0, a1, y, et) * Mvh(2)
            m3 = dlm(L, M, k0, a1, y, et) * Mvh(3)
            
            sumM1 = sumM1 + m1
            sumM2 = sumM2 + m2
            sumM3 = sumM3 + m3
            
            n1 = clm(L, M, k0, a1, y, et) * Nve(1)
            n2 = clm(L, M, k0, a1, y, et) * Nve(2)
            n3 = clm(L, M, k0, a1, y, et) * Nve(3)
            
            sumN1 = sumN1 + n1
            sumN2 = sumN2 + n2
            sumN3 = sumN3 + n3
        
        end do
    end do
    
    Ins(1) = (sumM1 + sumN1) * UnitStep(a1-r)
    Ins(2) = (sumM2 + sumN2) * UnitStep(a1-r)
    Ins(3) = (sumM3 + sumN3) * UnitStep(a1-r)

end subroutine Inside

subroutine Scattered(k0,r,theta,phi,y,et,a1,lim,Sca)

! =========================================================
! Name:    subroutine Scattered
!
! Purpose: calculating the scattered electric field
!
! Input:   k0 		-> wavenumber
!		   r		-> radial coordinate
!		   theta  	-> angular coordinate
!		   phi		-> angular coordinate
!		   y		-> polarization measurement
!		   et		-> dielectric permittivity
!		   a1		-> sphere radius
!		   lim		-> upper limit on l sum
! 
! Output:  Sca		-> scattered electric field vector
!
! Calls:   UnitStep, Mv3, Nv3
! =========================================================

    complex*16 :: m1, m2, m3, n1, n2, n3
    complex*16 :: sumM1, sumM2, sumM3, sumN1, sumN2, sumN3
    complex*16 :: alm, blm
    integer :: L, M, lim
    doubleprecision :: k0, r, theta, phi, y, et, a1, UnitStep
    complex*16, dimension(1:3) :: Mv3, Nv3, Sca
    
    sumM1 = 0.0
    sumM2 = 0.0
    sumM3 = 0.0
    
    sumN1 = 0.0
    sumN2 = 0.0
    sumN3 = 0.0
    
    do M = -1, 1, 2
        do L = 1, lim
        
            call Mv3Vector(k0,L,M,r,theta,phi,Mv3)
            call Nv3Vector(k0,L,M,r,theta,phi,Nv3)
            
            m1 = blm(L, M, k0, a1, y, et) * Mv3(1)
            m2 = blm(L, M, k0, a1, y, et) * Mv3(2)
            m3 = blm(L, M, k0, a1, y, et) * Mv3(3)
            
            sumM1 = sumM1 + m1
            sumM2 = sumM2 + m2
            sumM3 = sumM3 + m3
            
            n1 = alm(L, M, k0, a1, y, et) * Nv3(1)
            n2 = alm(L, M, k0, a1, y, et) * Nv3(2)
            n3 = alm(L, M, k0, a1, y, et) * Nv3(3)
            
            sumN1 = sumN1 + n1
            sumN2 = sumN2 + n2
            sumN3 = sumN3 + n3
        
        end do
    end do
    
    Sca(1) = (sumM1 + sumN1) * UnitStep(r-a1)
    Sca(2) = (sumM2 + sumN2) * UnitStep(r-a1)
    Sca(3) = (sumM3 + sumN3) * UnitStep(r-a1)

end subroutine Scattered

subroutine Incident(k0,r,theta,phi,y,et,a1,lim,Inc)

! =========================================================
! Name:    subroutine Incident
!
! Purpose: calculating the incident electric field
!
! Input:   k0 		-> wavenumber
!		   r		-> radial coordinate
!		   theta  	-> angular coordinate
!		   phi		-> angular coordinate
!		   y		-> polarization measurement
!		   et		-> dielectric permittivity
!		   a1		-> sphere radius
!		   lim		-> upper limit on l sum
! 
! Output:  Inc		-> incident electric field vector
!
! Calls:   UnitStep, Mvh, Nvh
! =========================================================

    complex*16 :: m1, m2, m3, n1, n2, n3
    complex*16 :: sumM1, sumM2, sumM3, sumN1, sumN2, sumN3
    complex*16 :: plm, qlm
    integer :: L, M, lim
    doubleprecision :: k0, r, theta, phi, y, et, a1, UnitStep
    complex*16, dimension(1:3) :: Mvh, Nvh, Inc
    
    sumM1 = 0.0
    sumM2 = 0.0
    sumM3 = 0.0
    
    sumN1 = 0.0
    sumN2 = 0.0
    sumN3 = 0.0
    
    do M = -1, 1, 2
        do L = 1, lim
        
            call MvhVector(k0,L,M,r,theta,phi,Mvh)
            call NvhVector(k0,L,M,r,theta,phi,Nvh)
            
            m1 = qlm(y, L, M) * Mvh(1)
            m2 = qlm(y, L, M) * Mvh(2)
            m3 = qlm(y, L, M) * Mvh(3)
            
            print*, "L = ", L, "M = ", M
            
            if (m1 /= m1) then
                print*, "m1 is NaN"
            else if (m1 == m1) then
                print *, "m1 is good"
            end if
            if (m2 /= m2) then
                print*, "m2 is NaN"
            else if (m2 == m2) then
                print *, "m2 is good"
            end if
            if (m3 /= m3) then
                print*, "m3 is NaN"
            else if (m3 == m3) then
                print *, "m3 is good"
            end if
            
            sumM1 = sumM1 + m1
            sumM2 = sumM2 + m2
            sumM3 = sumM3 + m3
            
            n1 = plm(y, L, M) * Nvh(1)
            n2 = plm(y, L, M) * Nvh(2)
            n3 = plm(y, L, M) * Nvh(3)
            
            sumN1 = sumN1 + n1
            sumN2 = sumN2 + n2
            sumN3 = sumN3 + n3
        
        end do
    end do
    
    Inc(1) = (sumM1 + sumN1) * UnitStep(r-a1)
    Inc(2) = (sumM2 + sumN2) * UnitStep(r-a1)
    Inc(3) = (sumM3 + sumN3) * UnitStep(r-a1)

end subroutine Incident

function dlm(L, M, k0, a, y, et)

! =========================================================
! Name:    function dlm
!
! Purpose: calculating the interior Mie coefficient d_lm
!
! Input:   k0 		-> wavenumber
!		   L,M		-> function order
!		   y		-> polarization measurement
!		   et		-> dielectric permittivity
!		   a		-> sphere radius
! 
! Output:  dlm		-> Mie coefficient dlm
!
! Calls:   besselDerivative, bessel, hankelDerivative, 
		   hankel, qlm
! =========================================================

    implicit none

    !Functions
    integer :: L, M
    doubleprecision :: besselDerivative, bessel, k0, a, y, et
    complex*16 :: dlm, hankelDerivative, qlm, hankel

    !Parts
    complex*16 :: c1, p1, p2, c2, p3, p4, c3
    doubleprecision :: DJarg

    DJarg = k0 * sqrt(et) * a !3459.768

        c1 = qlm(y,L,M)
    p1 = hankel(L, k0 * a) * besselDerivative(L , k0 * a) !Works
    p2 = bessel(L, k0 * a) * hankelDerivative(L, k0 * a) !Works
        c2 = (-1.0) * (p1 - p2)
    p3 = bessel(L, DJarg) * hankelDerivative(L, k0 * a)
    p4 = hankel(L, k0 * a) * besselDerivative(L, DJarg)
        c3 = p3 - p4

    dlm = c1 * (c2 / c3)

end function

function clm(L, M, k0, a, y, et)

! =========================================================
! Name:    function clm
!
! Purpose: calculating the interior Mie coefficient c_lm
!
! Input:   k0 		-> wavenumber
!		   L,M		-> function order
!		   y		-> polarization measurement
!		   et		-> dielectric permittivity
!		   a		-> sphere radius
! 
! Output:  clm		-> Mie coefficient clm
!
! Calls:   besselDerivative, bessel, hankelDerivative, 
		   hankel, plm
! =========================================================

    implicit none

    integer :: L, M
    doubleprecision :: besselDerivative, bessel, k0, a, y, et
    complex*16 :: clm, hankelDerivative, plm, hankel

    complex*16 :: c1, p1, p2, c2, p3, p4, c3
    doubleprecision :: DJarg
    DJarg = k0 * sqrt(et) * a 

        c1 = plm(y,L,M)
    p1 = hankel(L, k0 * a) * besselDerivative(L, k0 * a) !Works
    p2 = bessel(L, k0 * a) * hankelDerivative(L, k0 * a) !Works
        c2 = (-1.0) * (p1 - p2)
    p3 = bessel(L, DJarg) * hankelDerivative(L, k0 * a) !Works with L = 1 workaround
    p4 = hankel(L, k0 * a) * (1 / et) * besselDerivative(L, DJarg)
        c3 = p3 - p4

    clm = c1 * (c2 / c3)

end function

subroutine MveVector(k0,L,M,r,theta,phi,et,Mve)  ! works

! =========================================================
! Name:    subroutine MveVector
!
! Purpose: calculating the Mve vector
!
! Input:   k0 		-> wavenumber
!		   L,M		-> functino order
!		   r		-> radial coordinate
!		   theta  	-> angular coordinate
!		   phi		-> angular coordinate
!		   et		-> dielectric permittivity
! 
! Output:  Mve		-> Mve vector
!
! Calls:   psi, DpsiDT
! =========================================================
    complex*16 :: psi, DpsiDT, i, p1, p2, p3
    integer :: L, M
    doubleprecision :: k0, r, theta, phi, et
    complex*16, dimension(1:3) :: Mve
    
    i = CMPLX(0,1) 
    
    p1 = 0.0
    p2 = ((i * M) / (SIN(theta))) * psi(k0 * sqrt(et),r,L,M,theta,phi)
    p3 = (-1.0) * DpsiDT(k0 * sqrt(et),L,M,r,theta,phi)
    
    Mve(1) = (p1 * sin(theta) * cos(phi)) + (p2 * cos(theta) * cos(phi)) + (p3 * sin(phi) * (-1.0))
    Mve(2) = (p1 * sin(theta) * sin(phi)) + (p2 * cos(theta) * sin(phi)) + (p3 * cos(phi))
    Mve(3) = (p1 * cos(theta)) + (p2 * sin(theta) * (-1.0))
    
end subroutine MveVector

subroutine NveVector(k0,L,M,r,theta,phi,et,Nve)  ! works

! =========================================================
! Name:    subroutine NveVector
!
! Purpose: calculating the Nve vector
!
! Input:   k0 		-> wavenumber
!		   L,M		-> functino order
!		   r		-> radial coordinate
!		   theta  	-> angular coordinate
!		   phi		-> angular coordinate
!		   et		-> dielectric permittivity
! 
! Output:  Nve		-> Nve vector
!
! Calls:   psi, DR2psiDRDT, DRpsiDR
! =========================================================

    complex*16 :: psi, DR2psiDRDT, DRpsiDR, i, p1, p2, p3
    integer :: L, M
    doubleprecision :: k0, r, theta, phi, et, z
    complex*16, dimension(1:3) :: Nve
    
    i = CMPLX(0,1)
    z = k0 * sqrt(et)
    
    p1 = (L * (L+1.0) * psi(z,r,L,M,theta,phi) * 1.0) / (k0 * et * r * 1.0)
    p2 = (DR2psiDRDT(z,L,L,M,r,theta,phi) * 1.0) / (k0 * et * r * 1.0)
    p3 = (i * M * DRpsiDR(z,L,L,M,r,theta,phi) * 1.0) / (k0 * et * r * sin(theta) * 1.0)
    
    Nve(1) = (p1 * sin(theta) * cos(phi)) + (p2 * cos(theta) * cos(phi)) + (p3 * sin(phi) * (-1.0))
    Nve(2) = (p1 * sin(theta) * sin(phi)) + (p2 * cos(theta) * sin(phi)) + (p3 * cos(phi)) 
    Nve(3) = (p1 * cos(theta)) + (p2 * sin(theta) * (-1.0))
    
end subroutine NveVector

subroutine Nv3Vector(k0,L,M,r,theta,phi,Nv3) ! works

! =========================================================
! Name:    subroutine Nv3Vector
!
! Purpose: calculating the Nv3 vector
!
! Input:   k0 		-> wavenumber
!		   L,M		-> functino order
!		   r		-> radial coordinate
!		   theta  	-> angular coordinate
!		   phi		-> angular coordinate
!		   et		-> dielectric permittivity
! 
! Output:  Nv3		-> Nv3 vector
!
! Calls:   psi2, DR2psi2DRDT, DRpsi2DR
! =========================================================
    complex*16 :: psi2, DR2psi2DRDT, DRpsi2DR, i, p1, p2, p3
    integer :: L, M
    doubleprecision :: k0, r, theta, phi
    complex*16, dimension(1:3) :: Nv3
    
    i = CMPLX(0,1)
    
    p1 = (L * (L+1.0) * psi2(k0,r,L,M,theta,phi) * 1.0) / (k0 * r * 1.0)
    p2 = (DR2psi2DRDT(k0,L,L,M,r,theta,phi) * 1.0) / (k0 * r * 1.0)
    p3 = (i * M * DRpsi2DR(k0,L,L,M,r,theta,phi) * 1.0) / (k0 * r * sin(theta) * 1.0)
    
    Nv3(1) = (p1 * sin(theta) * cos(phi)) + (p2 * cos(theta) * cos(phi)) + (p3 * sin(phi) * (-1.0))
    Nv3(2) = (p1 * sin(theta) * sin(phi)) + (p2 * cos(theta) * sin(phi)) + (p3 * cos(phi)) 
    Nv3(3) = (p1 * cos(theta)) + (p2 * sin(theta) * (-1.0))
    
end subroutine Nv3Vector

subroutine Mv3Vector(k0,L,M,r,theta,phi,Mv3) ! works

! =========================================================
! Name:    subroutine Mv3Vector
!
! Purpose: calculating the Mv3 vector
!
! Input:   k0 		-> wavenumber
!		   L,M		-> functino order
!		   r		-> radial coordinate
!		   theta  	-> angular coordinate
!		   phi		-> angular coordinate
!		   et		-> dielectric permittivity
! 
! Output:  Mv3		-> Mv3 vector
!
! Calls:   psi2, Dpsi2DT
! =========================================================

    complex*16 :: psi2, Dpsi2DT, i, p1, p2, p3
    integer :: L, M
    doubleprecision :: k0, r, theta, phi
    complex*16, dimension(1:3) :: Mv3
    
    i = CMPLX(0,1)
    
    p1 = 0.0
    p2 = ((i * M) / (SIN(theta))) * psi2(k0,r,L,M,theta,phi)
    p3 = (-1.0) * Dpsi2DT(k0,L,L,M,r,theta,phi)
    
    Mv3(1) = (p1 * sin(theta) * cos(phi)) + (p2 * cos(theta) * cos(phi)) + (p3 * sin(phi) * (-1.0))
    Mv3(2) = (p1 * sin(theta) * sin(phi)) + (p2 * cos(theta) * sin(phi)) + (p3 * cos(phi))
    Mv3(3) = (p1 * cos(theta)) + (p2 * sin(theta) * (-1.0))
    
end subroutine Mv3Vector

subroutine NvhVector(k0,L,M,r,theta,phi,Nvh) ! works

! =========================================================
! Name:    subroutine NvhVector
!
! Purpose: calculating the Nvh vector
!
! Input:   k0 		-> wavenumber
!		   L,M		-> functino order
!		   r		-> radial coordinate
!		   theta  	-> angular coordinate
!		   phi		-> angular coordinate
!		   et		-> dielectric permittivity
! 
! Output:  Nvh		-> Nvh vector
!
! Calls:   psi, DR2psiDRDT, DRpsiDR
! =========================================================

    complex*16 :: psi, DR2psiDRDT, DRpsiDR, i, p1, p2, p3
    integer :: L, M
    doubleprecision :: k0, r, theta, phi
    complex*16, dimension(1:3) :: Nvh
    
    i = CMPLX(0,1)
    
    p1 = (L * (L+1.0) * psi(k0,r,L,M,theta,phi) * 1.0) / (k0 * r * 1.0)
    p2 = (DR2psiDRDT(k0,L,L,M,r,theta,phi) * 1.0) / (k0 * r * 1.0)
    p3 = (i * M * DRpsiDR(k0,L,L,M,r,theta,phi) * 1.0) / (k0 * r * sin(theta) * 1.0)
    
    Nvh(1) = (p1 * sin(theta) * cos(phi)) + (p2 * cos(theta) * cos(phi)) + (p3 * sin(phi) * (-1.0))
    Nvh(2) = (p1 * sin(theta) * sin(phi)) + (p2 * cos(theta) * sin(phi)) + (p3 * cos(phi))
    Nvh(3) = (p1 * cos(theta)) + (p2 * sin(theta) * (-1.0))
    
end subroutine NvhVector

subroutine MvhVector(k0,L,M,r,theta,phi,Mvh) ! works

! =========================================================
! Name:    subroutine MvhVector
!
! Purpose: calculating the Mvh vector
!
! Input:   k0 		-> wavenumber
!		   L,M		-> functino order
!		   r		-> radial coordinate
!		   theta  	-> angular coordinate
!		   phi		-> angular coordinate
!		   et		-> dielectric permittivity
! 
! Output:  Mvh		-> Mvh vector
!
! Calls:   psi, DpsiDT
! =========================================================

    complex*16 :: psi, DpsiDT, i, p1, p2, p3
    integer :: L, M
    doubleprecision :: k0, r, theta, phi
    complex*16, dimension(1:3) :: Mvh
    
    i = CMPLX(0,1)
    
    p1 = 0.0
    p2 = ((i * M) / (SIN(theta))) * psi(k0,r,L,M,theta,phi)
    p3 = (-1.0) * DpsiDT(k0,L,M,r,theta,phi)
    
    Mvh(1) = (p1 * sin(theta) * cos(phi)) + (p2 * cos(theta) * cos(phi)) + (p3 * sin(phi) * (-1.0))
    Mvh(2) = (p1 * sin(theta) * sin(phi)) + (p2 * cos(theta) * sin(phi)) + (p3 * cos(phi))
    Mvh(3) = (p1 * cos(theta)) + (p2 * sin(theta) * (-1.0))
    
end subroutine MvhVector

function UnitStep(x)

! =========================================================
! Name:    function UnitStep
!
! Purpose: calculating the unit step function
!
! Input:   x		-> input
! 
! Output:  UnitStep -> either 0 or 1
!
! Calls:   N/A
! =========================================================

    doubleprecision :: UnitStep, x
    
    if (x >= 0) then
    
        UnitStep = 1.0
        
    else if (x < 0) then
    
        UnitStep = 0.0
    
    end if
    
end function UnitStep

